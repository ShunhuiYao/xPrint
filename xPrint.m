(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



xAct`xPrint`$Version={"1.4",{2015,4,15}};
xAct`xPrint`$xPermVersionExpected={"1.0.3",{2009,9,9}};


(* xPrint: Point-and-Click WYSIWYG tensor input for xAct, *)

(* Copyright (C) 2010 Alessandro Stecchina *)

(* This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published
 by the Free Software Foundation; either version 2 of the License,
  or (at your option) any later version.

This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place-Suite 330, Boston, MA 02111-1307,
  USA. 
*)


(* :Title: xPrint *) 

(* :Author: Alessandro Stecchina *)

(* :Summary: Point-and-Click WYSIWYG tensor input for xAct *)

(* :Brief Discussion:
 State-of-the-art palette interface to the xAct suite of Mathematica packages
 Select manifolds, tensors, indices and derivative operators via pull-down menus
 Real-time wysiwyg tensor object construction
 VBundle-constrained menu-driven index selection
 Abstract and b and c indices
 On-the-fly syntax checking
 One-click pasting of formatted tensor objects into notebooks
*)
  
(* :Context: xAct`xPrint` *)

(* :Copyright: Alessandro Stecchina (2010-2015) *)

(* :History:
Vers. 1.4
	17 Apr 2015
	All sectons have the same width as the maipulation section
	Many new buttons in Tensor manipulation section
	TabView in Tensor manipulation section
	Help menu with access to xPrint tutorials
	xPrint is now in a single folder with documentation files
	xTerior is loaded automatically with xPrint
	Algebraic operations buttons added
	Exterior forms section added
	Gdelta Menu supprts symbolic dimension
	Gdelta bug fixed
	Upgraded to xAct 1.1.0 and Mathematica 10.x
Vers. 1.1
	19 Aug 2010
	Label indices
	Basis menu now with bases names and colored dots now made with FilledCircle
	Primed and double primed indices using Primed and DoublePrimed options
Vers. 1.01
	18 Jul 2010
	Reduced overall font size
	Manifold menu moved on top
Vers. 1.0
	20 Jun 2010
	WYSIWYG input of derivatives
	Solved SlotOftensor problem
	Target nb and Lock
	Tensor manipulation section started
	"About xPrint" help menu item
	Splashscreen
Vers. 0.997
	Predefined tensor slots are enforced when a metric is not present
	Applied dividers to the main sections
Vers. 0.996
	Help menu added, linking to xAct documentation
	Definition section added using enhanced template technology
	Global Environment section added
Vers. 0.995
	No-manifold-red-box problem fixed
	PasteButton appearance changed to Button
	Added:Basis in the Tensor menu
	Better handling of indices of Basis and delta 
	Patch to interpretbox of xTensor to fix the blue-index problem.
Vers. 0.99
	b and c index support
	parameter menu
	OpenerViews
	General Settings section
	Bases and Charts section
Vers. 0.62
	Main menus have been tooltipped
Vers. 0.60
	First public release 17 Mar 2010
	Derivatives menu
Vers. 0.50
	Jan 2010
	Jan 29 xPrint name proposed
	Manifold and Tensor menus
	Created out of interstellar dust

*)

(* :Keywords: *)

(* :Source: xPrint.nb *)

(* :Warning: *)

(* :Mathematica Version: 7.0 and later *)

(* :Limitations: can't prepare Tiramisu...yet *)


If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`xPrint`"];


BeginPackage["xAct`xPrint`",{"xAct`xCore`","xAct`xPerm`","xAct`xTensor`","xAct`xCoba`","xAct`xTerior`"}]


If[Not@OrderedQ@Map[Last,{$xPermVersionExpected,xAct`xPerm`$Version}],Throw@Message[General::versions,"xPerm",xAct`xPerm`$Version,$xPermVersionExpected]]


Print[xAct`xCore`Private`bars];
Print["Package xAct`xPrint`  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2010-2015, Alessandro Stecchina, under the General Public License."]


Off[General::shdw]
xAct`xPrint`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


If[xAct`xCore`Private`$LastPackage==="xAct`xPrint`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


(* xPrintPalette::usage = "xPrintPalette creates a session palette for pasting tensor input."; *)
xPrintValidQ::usage = "xPrintValidQ[expr] returns True if expr is syntactically correct and False otherwise.";
(*
DefPrimedBasis::usage = "DefPrimedBasis[basis,vbundle,{c1,...,cn}] defines a basis with primed indices. It passes all its arguments to DefBasis";
DefDoublePrimedBasis::usage = "DefDoublePrimedBasis[basis,vbundle,{c1,...,cn}] defines a basis with double-primed indices. It passes all its arguments to DefBasis";
DefPrimedChart::usage = "DefPrimedChart[basis,vbundle,{c1,...,cn}] defines a chart with primed indices. It passes all its arguments to DefChart";
DefDoublePrimedChart::usage = "DefDoublePrimedChart[basis,vbundle,{c1,...,cn}] defines a chart with double-primed indices. It passes all its arguments to DefChart";
*)
(*
xPrintpaste::usage = "paste the palette";
xPrintPalette::usage = "palette object";
*)


xAct`xCoba`Primed::usage="Primed is an option of DefBasis and DefChart. If True, basis or chart indices are printed with a prime. Default is False";
xAct`xCoba`DoublePrimed::usage="DoublePrimed is an option of DefBasis and DefChart. If True, basis or chart indices are printed with a double-prime. Default is False";


Unprotect[DefBasis];
(*added Primed and DoublePrimed*)
Options[DefBasis]={
BasisColor->RGBColor[1,0,0],
FormatBasis->Automatic,
ProtectNewSymbol:>$ProtectNewSymbols,
Dagger->Real,
ExtendedFrom->Null,
MetricInBasis->{},
BasisChange->Null,
epsilonOrientationOfMetric->{Null,1},
DependenciesOfBasis->{},
DefInfo->{"basis",""},
Master->Null,
Primed->False,
DoublePrimed->False
};
(*
DefBasis[basisname_,vbundle_Symbol,cnumbers_,options___]:=
(*added pr and dpr to local variables and to the list of options, together with Primed and DoublePrimed*)
Module[{bc,pns,dag,ef,mb,mb3,dim,tanb,covdef,info,master,pr,dpr,manifold=BaseOfVBundle[vbundle],tbundle},
{bc,pns,dag,ef,mb,deps,info,master,pr,dpr}={BasisColor,ProtectNewSymbol,Dagger,ExtendedFrom,MetricInBasis,DependenciesOfBasis,DefInfo,Master,Primed,DoublePrimed}/.CheckOptions[options]/.Options[DefBasis];
*)

DefBasis[basisname_,vbundle_,cnumbers_,options:OptionsPattern[]]:=
(*added pr and dpr to local variables and to the list of options, together with Primed and DoublePrimed*)Module[{bc,fb,pns,dag,ef,mb,change,eoom,deps,mb3,dim,tanb,covdef,info,master,pr,dpr,manifold=BaseOfVBundle[vbundle],tbundle},
{bc,fb,pns,dag,ef,mb,change,eoom,deps,info,master,pr,dpr}=OptionValue[{BasisColor,FormatBasis,ProtectNewSymbol,Dagger,ExtendedFrom,MetricInBasis,BasisChange,epsilonOrientationOfMetric,DependenciesOfBasis,DefInfo,Master,Primed,DoublePrimed}];

(**** Checks ****)
       (* Check names *)
If[!VBundleQ[vbundle],Throw@Message[DefBasis::unknown,"vbundle",vbundle]];
dim=DimOfVBundle[vbundle];
If[ChartQ[basisname],
If[BasisQ[basisname],
(* The basis already exists. This is a duplicated name *)
Throw@Message[ValidateSymbol::used,basisname,"as a basis"],
(* Coordinate basis being defined. Symbol validation already performed. Do nothing *)
Null
],
(* Noncoordinate basis. Perform symbol validation *)
ValidateSymbol[basisname];
ValidateSymbolInSession[basisname]
];
(* Check cnumbers: heads, length and integer type. Repeated cnumbers are not allowed *)
If[Or[
Head[cnumbers]=!=List,
Union[cnumbers]=!=Sort[cnumbers],
Not[And@@(IntegerQ/@cnumbers)],
Length[cnumbers]=!=dim],
Throw@Message[DefBasis::invalid,cnumbers,"list of cnumbers"]];
(* Check complex option *)
If[FreeQ[{Real,Complex,Conjugate},dag],Throw@Message[DefBasis::invalid,dag,"value for option Dagger"]];
If[DaggerQ[vbundle]&&dag===Real,Throw@Message[DefBasis::error,"Cannot define a real basis on a complex manifold."]];
(* Check dependencies *)
If[Not@Or[ManifoldQ[#],ParameterQ[#]],Throw@Message[DefBasis::invalid,#,"dependency"]]&/@deps;
If[FreeQ[deps,manifold],deps=Prepend[deps,manifold]];
(* Check extension from other basis *)
covdef=If[ef=!=Null,
If[!BasisQ[ef],Throw@Message[DefBasis::unknown,"basis",ef]];
tanb=VBundleOfBasis[ef];
If[TangentBundleOfManifold@BaseOfVBundle@tanb=!=tanb,Throw@Message[DefBasis::invalid,ef,"basis to extend"]];
If[BaseOfVBundle@tanb=!=manifold,Throw@Message[DefBasis::invalid,ef,"basis to extend"]];
PDOfBasis[ef],
Null];
(* Check mb *)
If[mb=!={},
If[MatchQ[mb,{_?MetricQ,basisname|-basisname,_}],
Switch[mb3=mb[[3]],
"Orthogonal"|"Orthonormal",Null,
_List,If[Dimensions[mb3]=!={dim}&&Dimensions[mb3]=!={dim,dim},Throw@Message[DefBasis::invalid,mb3,"array of metric values"]],
_,Throw@Message[DefBasis::invalid,mb3,"metric values specification"]
],
Throw@Message[DefBasis::invalid,mb,"value for option MetricInBasis"]
]
];
(* Check change *)
If[change=!=Null,
If[!MatchQ[change,HoldPattern[CTensor[_?MatrixQ,{-basisname,_?BasisQ},0]]],
Throw@Message[DefBasis::invalid,change,"basis change specification"]]
];
(* Check eoom *)
If[Head[eoom]=!=List||Length[eoom]=!=2,
Throw@Message[DefBasis::invalid,eoom,"value for option epsilonOrientationOfMetric"];
];
If[eoom[[1]]=!=Null&&!MetricQ[eoom[[1]]],
Throw@Message[DefBasis::unknown,"metric",eoom[[1]]];
];

(**** Define basis ****)
xAct`xTensor`Private`MakeDefInfo[DefBasis,basisname,info];
MakexTensions[DefBasis,"Beginning",basisname,vbundle,cnumbers,options];
(* Register *)
AppendTo[$Bases,basisname];
BasisQ[basisname]^=True;
BasisColor[basisname]^=bc;
VBundleOfBasis[basisname]^=vbundle;
basisname/:CNumbersOf[basisname,vbundle]=Sort@cnumbers;
etaOrientation[basisname]^=Signature[cnumbers];
If[eoom[[1]]=!=Null,basisname/:epsilonOrientation[eoom[[1]],basisname]=eoom[[2]]];
DependenciesOfBasis[basisname]^=deps;
DefInfo[basisname]^=info;
xAct`xTensor`Private`SymbolRelations[basisname,master,{vbundle}];
(* Define associated parallel derivative, always real *)
tbundle=TangentBundleOfManifold[manifold];
With[
{indtng=First@GetIndicesOfVBundle[tbundle,1],
pdbasis=If[HasDaggerCharacterQ[basisname],PDOfBasis[Dagger[basisname]],GiveSymbol[PD,basisname]]},
PDOfBasis[basisname]^=pdbasis;
If[dag=!=Conjugate,
(* Quiet OptionValue::nodef because we are passing DefBasis/DefChart options *)
Quiet[
DefCovD[pdbasis[-indtng],vbundle,{ColorString[$PDPostfixSymbol,bc],ColorString[$PDPrefixSymbol,bc]},Torsion:>Not@ChartQ[basisname],Curvature->False,Master->basisname,ExtendedFrom->covdef,DefInfo->If[info===False,False,{"parallel derivative",""}],options],
OptionValue::nodef];
If[Not@ChartQ[basisname],With[{torsion=Torsion[basisname]},xAct`xTensor`Private`SetPrintAs[torsion,ColorString["T",bc]]]];
BasisOfCovD[pdbasis]^=basisname;
If[dag===Complex,Set[Evaluate[MakeDaggerSymbol[pdbasis]],pdbasis]] 
] 
];
(* Store positions of cnumbers *)
MapIndexed[Set[PNumber[#1,basisname],First[#2]]&,CNumbersOf[basisname,vbundle]];
MapIndexed[Set[PNumber[#1,-basisname],First[#2]]&,CNumbersOf[basisname,vbundle]];
(* Properties of basis under complex conjugation *)
Switch[dag,
Real,Dagger[basisname]^=basisname,
Conjugate,Null,
Complex,
xAct`xTensor`Private`SetDaggerPair[basisname,MakeDaggerSymbol[basisname]];
DefBasis[Dagger[basisname],Dagger[vbundle],cnumbers,Dagger->Conjugate,Master->basisname,options]
];
(* Register change of basis *)
If[change=!=Null,SetBasisChange[change]];
(* Store values of components of some metric in this basis *)
If[mb=!={},Apply[MetricInBasis,mb]];
(* Define associated eta tensors, even for inner vbundles *)
defeta[basisname,dag,info];
(* Format bases elements *)
If[fb=!=Automatic,
If[!MatchQ[fb,{_List,_List}],Throw@Message[DefBasis::invalid,fb,"value for option FormatBasis"]];
FormatUpVectors[fb[[1]],CIndicesOf[-basisname],scalars];
FormatDownVectors[fb[[2]],CIndicesOf[basisname],scalars];
];

MakexTensions[DefBasis,"End",basisname,vbundle,cnumbers,options];

If[pns,Protect[basisname]];
(*added the next lines to launch my internal functions*)
If[pr,xAct`xPrint`Private`PrimedIndexForm[basisname]];
If[dpr,xAct`xPrint`Private`DoublePrimedIndexForm[basisname]];
];
SetNumberOfArguments[DefBasis,{3,Infinity}];
Protect[DefBasis];


Unprotect[DefChart];
(*added Primed and DoublePrimed*)
(*
Options[DefChart]={ChartColor\[Rule]RGBColor[1,0,0],ProtectNewSymbol\[RuleDelayed]$ProtectNewSymbols,Dagger\[Rule]Real,MetricInBasis\[Rule]{},Primed\[Rule]False,
DoublePrimed\[Rule]False};
*)
Options[DefChart]={
ChartColor->RGBColor[1,0,0],
FormatBasis->Automatic,
ProtectNewSymbol:>$ProtectNewSymbols,
Dagger->Real,
MetricInBasis->{},
epsilonOrientationOfMetric->{Null,1},
ExtendedCoordinateDerivatives->True,
DefInfo->{"chart",""},
Primed->False,
DoublePrimed->False
};

DefChart[chartname_,manifold_,cnumbers_,scalars_List,options:OptionsPattern[]]:=
With[{pd=GiveSymbol[PD,chartname],heads=Head/@scalars,index=IndicesOfVBundle[TangentBundleOfManifold[manifold]][[1,1]]},
(*added pr and dpr to local variables and to the list of options, together with Primed and DoublePrimed*)
Module[{cc,fb,pns,dag,eoom,ecd,info,prot,dheads,pheads,pr,dpr},
{cc,fb,pns,dag,eoom,ecd,info,pr,dpr}=OptionValue[{ChartColor,FormatBasis,ProtectNewSymbol,Dagger,epsilonOrientationOfMetric,ExtendedCoordinateDerivatives,DefInfo,Primed,DoublePrimed}];
(* dheads=Map[SymbolJoin["d",#]&,heads];
pheads=Map[SymbolJoin["p",#]&,heads]; *)

(* Checks *)
ValidateSymbol[chartname];
ValidateSymbolInSession[chartname];
If[!ManifoldQ[manifold],Throw@Message[DefChart::unknown,"manifold",manifold]];
If[!IntegerQ[DimOfManifold[manifold]],Throw@Message[DefChart::error,"Chart cannot be defined on a manifold with symbolic dimension."]];
If[Not@And@@Join[IntegerQ/@cnumbers],Throw@Message[DefChart::error,"The cnumbers must be integers."]];
If[DimOfManifold[manifold]!=Length[cnumbers],Throw@Message[DefChart::error,"Incorrect number of cnumbers supplied."]];
If[DimOfManifold[manifold]!=Length[scalars],Throw@Message[DefChart::error,"Incorrect number of scalars supplied."]];
(* Check eoom *)
If[Head[eoom]=!=List||Length[eoom]=!=2,
Throw@Message[DefChart::invalid,eoom,"value for option epsilonOrientationOfMetric"];
];
If[!xTensorQ[#],ValidateSymbol[#]&&ValidateSymbolInSession[#]]&/@heads;
(* ValidateSymbolInSession/@dheads;
ValidateSymbolInSession/@pheads; *)

MakexTensions[DefChart,"Beginning",chartname,manifold,cnumbers,scalars,options];

(* Register *)
xAct`xTensor`Private`MakeDefInfo[DefChart,chartname,info];
ChartQ[chartname]^=True;
ManifoldOfChart[chartname]^=manifold;
ChartColor[chartname]^=cc;
AppendTo[$Charts,chartname];
(* Changes of coordinates *)
xAct`xTensor`Private`SymbolRelations[chartname,Null,{manifold}];

(* Define coordinate scalars if they do not exist yet *)
prot=Unprotect/@heads;
ServantsOf[chartname]^={};
If[!xTensorQ[Head[#]],DefTensor[#,manifold,Master->chartname,DefInfo->If[info===False,False,{"coordinate scalar",""}]]]&/@scalars;
MapIndexed[setinchart[chartname],scalars];
ScalarsOfChart[chartname]^=scalars;
(* ChartRules[chartname]^=Thread@Rule[manifold/@cnumbers,scalars];*)
(* Store coordinate names *)
Inner[Set,Coordinate[#,chartname]&/@cnumbers,heads,List];

(* Define associated mapping to Reals[dim] *)
DefMapping[chartname, manifold-> Reals[DimOfManifold[manifold]],ImmersionQ->True,SubmersionQ->True,InverseMapping->Automatic];
With[{inv=InverseMapping[chartname]},ChartIMapQ[inv]^=True];

(* Define associated basis, which in turn defines the parallel derivative. Turn off formating. Quiet OptionValue::nodef because we are passing DefChart options *)
Quiet[DefBasis[chartname,TangentBundleOfManifold[manifold],cnumbers,FormatBasis->Automatic,DefInfo->{"basis","Coordinated basis."},options,BasisColor->cc],OptionValue::nodef];
(* Define shortcuts for basis elements
Inner[Hold,Through[dheads[index_]],basis[{#,chartname},index]&/@cnumbers,List]/.basis\[Rule]Basis/.Hold\[Rule]SetDelayed;
Inner[Hold,Through[pheads[index_]],basis[{#,-chartname},index]&/@cnumbers,List]/.basis\[Rule]Basis/.Hold\[Rule]SetDelayed;*)
(* Define position vector *)
(* Format bases elements *)
If[fb=!=Automatic,
If[!MatchQ[fb,{_,_}],Throw@Message[DefChart::invalid,fb,"value for option FormatBasis"]];
FormatUpVectors[fb[[1]],CIndicesOf[-chartname],scalars];
FormatDownVectors[fb[[2]],CIndicesOf[chartname],scalars];
];
(* If MetricInBasis is specified, should we automatically compute Christoffels? *)

(* Any derivative of a coordinate scalar field gives a Basis vector *)
Inner[coordinateder[chartname,ecd],heads,cnumbers,List];

MakexTensions[DefChart,"End",chartname,manifold,cnumbers,scalars,options];

Protect[Evaluate[prot]];
];
(*added the next lines to launch my internal functions*)
If[pr,xAct`xPrint`Private`PrimedIndexForm[chartname]];
If[dpr,xAct`xPrint`Private`DoublePrimedIndexForm[chartname]];
];
SetNumberOfArguments[DefChart,{4,Infinity}];
Protect[DefChart];


Unprotect[Basis];
SlotsOfTensor[Basis]^:={-All,All};
Protect[Basis];


Begin["`Private`"]


(* If you do not like these initial settings, just comment-out any of the following 6 lines of code *)
$CovDFormat="Postfix";   (* no Covariant Deltas initially *)
ABCOnQ=False; (* Automatic basis contraction start *)
$PrePrint=ScreenDollarIndices;
$DefInfoQ=False;  (* No  Def-inition info messages *)
$UndefInfoQ=False; (* No  Undef-inition info messages *)
$CVVerbose=False;  (* Component Value verbose off*)
(*-------------------------------------------------------------------------------------------*)
PostfixStyleQ:=$CovDFormat=="Postfix"; (* turn it into a switch *)
IndicesScreenedQ:=$PrePrint==ScreenDollarIndices ;(* turn it into a switch *)
manifold="";
LieDSymbol="\[ScriptCapitalL]";
SimpleManipulationQ:=True  ;
indexform=unprimed


xPrintValidQ[expr_]:=Check[Validate[expr];True,False]//Quiet
SetAttributes[xPrintValidQ,HoldFirst];
(*------------------------------------------------------------*)
basisreset[basis_]:=(Table[basischoice[k]=basis,{k,30}];cbasischoice[1]=basis;)
(* lblposreset=Table[lblpos[k]=1;linput[k]=Null,{k,30}]; *)
labelreset=Table[label[k]="";linput[k]=Null,{k,30}];
(*------------------------------------------------------------*)
idxup[cdup_,basis_]:=cdup/;basis===AIndex
idxup[cdup_,basis_]:={cdup,basis}
(*------------------------------------------------------------*)
idxdown[cdown_,basis_]:=-cdown/;basis===AIndex
idxdown[cdown_,basis_]:={If[MemberQ[(IndicesOfVBundle@VBundleOfBasis[basis])[[1]],cdown],-cdown,cdown],-basis}
(*------------------------------------------------------------*)
idx[int_Integer]:=If[up[int]==="",-down[int],up[int]]/;basischoice[int]===AIndex
idx[int_Integer]:=If[up[int]==="",{If[MemberQ[(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]],down[int]],-down[int],down[int]],-basischoice[int]},{up[int],basischoice[int]}]
(*------------------------------------------------------------*)
lblsign[int_]:=Which[lblpos[int]==1,-1,lblpos[int]==2,1]
slot[int_Integer,tensorhead_]:=Switch[
Which[tensorhead===Gdelta,GdeltaSlots[gdslots]TangentBundleOfManifold[manifold],
True,SlotsOfTensor[tensorhead]][[int]],
Labels,LI@label[int],
-Labels,-LI@label[int],
_,idx[int]]
(*
slot[int_Integer,tensorhead_]:=If[SlotsOfTensor[tensorhead][[int]]===Labels||SlotsOfTensor[tensorhead][[int]]===-Labels,lblsign[int]LI@label[int],idx[int]]
*)
(*------------------------------------------------------------*)
cidx[int_Integer]:=If[cup[int]==="",-cdown[int],cup[int]]/;cbasischoice[int]===AIndex
cidx[int_Integer]:=If[cup[int]==="",{If[MemberQ[(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]],cdown[int]],-cdown[int],cdown[int]],-cbasischoice[int]},{cup[int],cbasischoice[int]}]
(*------------------------------------------------------------*)
GdeltaSlots[gdslots_]:=Join[ConstantArray[-1,gdslots],ConstantArray[1,gdslots]]
(*------------------------------------------------------------*)
pastedexpr:=Which[
manifold==="","No Manifold",
tensorhead==="" && cdchoice==="","No expression",
tensorhead===delta && \[Not]MetricEndowedQ[TangentBundleOfManifold[manifold]]&&(down[1]===""||up[2]===""),"Not a tensor",
tensorhead===Basis &&\[Not]MetricEndowedQ[TangentBundleOfManifold[manifold]]&& (down[1]===""||up[2]===""),"Not a tensor",
tensorhead===Gdelta &&\[Not]MetricEndowedQ[TangentBundleOfManifold[manifold]]&& Or@@Flatten@Table[{down[ii]==="",up[ii+gdslots]===""},{ii,gdslots}],"Not a tensor",
tensorhead=!="",completetensor[tensorhead],
cdchoice===LieD,"LieD" (*  this value is not used *),
cdchoice===ParamD &&paramchoice=!="","ParamD" (*  this value is not used *),
cdchoice===OverDot,"OverDot" (*  this value is not used *),
cdchoice===Bracket && (cdown[1]=!=""||cup[1]=!=""),(Bracket@@Table[cidx[k],{k,1}])[] ,
cdchoice=!=""&& (cdown[1]=!=""||cup[1]=!=""),(cdchoice@@Table[cidx[k],{k,1}])[] ,
cdchoice=!="","No Cov. Derivative"
]
(*------------------------------------------------------------*)
(*
completetensor[tensorhead_?xTensorQ]:=If[xPrintValidQ[
tensorhead@@Table[
idx[k],
{k,Which[tensorhead===Gdelta,2gdslots,
tensorhead===delta,2,
tensorhead===Basis,2,
True,Length@SlotsOfTensor[tensorhead]]//Evaluate}
]//Evaluate],
tensorhead@@Table[
idx[k],
{k,Which[tensorhead===Gdelta,2gdslots,
tensorhead===delta,2,
tensorhead===Basis,2,
True,Length@SlotsOfTensor[tensorhead]]//Evaluate}
] //ScreenDollarIndices
, "Not a tensor"
]
*)
completetensor[tensorhead_?xTensorQ]:=If[xPrintValidQ[
tensorhead@@Table[
slot[k,tensorhead],
{k,Which[tensorhead===Gdelta,2gdslots,
True,Length@SlotsOfTensor[tensorhead]]//Evaluate}
]//Evaluate],
tensorhead@@Table[
slot[k,tensorhead],
{k,Which[tensorhead===Gdelta,2gdslots,
tensorhead===delta,2,
tensorhead===Basis,2,
True,Length@SlotsOfTensor[tensorhead]]//Evaluate}
] //ScreenDollarIndices
, "Not a tensor"
]
completetensor[tensorhead_]:= "Not a tensor"
(*------------------------------------------------------------*)
(* My cnumbersof function *)
cnumbersof[basis_]:=CNumbersOf[basis ]/;basis=!=AIndex
cnumbersof[basis_]:={}
(*------------------------------------------------------------*)
abstractandbasesall:={AIndex}~Join~$Bases
(*------------------------------------------------------------*)
abstractandbases[manifold_]:={AIndex}~Join~Select[$Bases,(VBundleOfBasis[#]===TangentBundleOfManifold[manifold])&]
(*------------------------------------------------------------*)
(* this function also displays the basis name *)
abstractandbasesdisks[manifold_]:={Style["\[FilledCircle]"<>"  "<>"AIndex",Black]}~Join~(MapThread[Style["\[FilledCircle]"<>"  "<>ToString@#2,#1]&,{BasisColor/@Select[$Bases,(VBundleOfBasis[#]===TangentBundleOfManifold[manifold])&],Select[$Bases,(VBundleOfBasis[#]===TangentBundleOfManifold[manifold])&]}])
(*------------------------------------------------------------*)
tensormenuselection[manifold_]:=($Tensors\[Intersection]VisitorsOf[manifold])\[Union]{delta,Gdelta,Basis}/;$Manifolds=!={}&&manifold=!=""
tensormenuselection[manifold_]:={}
(*------------------------------------------------------------*)
(* all derivatives operators on a manifold *)
derivativesmenuselection[manifold_]:={PD,Diff,LieD,Bracket}~Join~(($CovDs\[Intersection]VisitorsOf[manifold])\[Union]{ParamD,OverDot})/;$Manifolds=!={}&&manifold=!=""
derivativesmenuselection[manifold_]:={}
(*------------------------------------------------------------*)
(* all commutable derivatives operators on a manifold *)
commderivativesmenuselection[manifold_]:={PD}~Join~($CovDs\[Intersection]VisitorsOf[manifold])/;$Manifolds=!={}&&manifold=!=""
commderivativesmenuselection[manifold_]:={}
(*------------------------------------------------------------*)
BracketTagUp[basis_]:="Bracket"<>"_"<>ToString[basis]<>"_"<>"Tag"<>"Up"
BracketTagsListUp:=BracketTagUp/@abstractandbasesall
BracketTagDown[basis_]:="Bracket"<>"_"<>ToString[basis]<>"_"<>"Tag"<>"Down"
BracketTagsListDown:=BracketTagDown/@abstractandbasesall
(*------------------------------------------------------------*)
StringTagPrefixUp[cdchoice_,basis_]:=ToString[cdchoice]<>"_"<>ToString[basis]<>"_"<>"Tag"<>"PrefixUp"
StringTagPrefixDown[cdchoice_,basis_]:=ToString[cdchoice]<>"_"<>ToString[basis]<>"_"<>"Tag"<>"PrefixDown"
StringTagsListPrefixUp:=Outer[StringTagPrefixUp,$CovDs,abstractandbasesall]//Flatten
StringTagsListPrefixDown:=Outer[StringTagPrefixDown,$CovDs,abstractandbasesall]//Flatten
(*
StringTagPostfix[cdchoice_]:=ToString[cdchoice]<>"Tag"<>"Postfix"
StringTagsListPostfix:=StringTagPostfix/@$CovDs
*)
(*------------------------------------------------------------*)
ButtonLabelStyle[x_]:=Style[x,10]
(*------------------------------------------------------------*)
PrimedIndexForm[basis_]:=(Unprotect[IndexForm];
IndexForm[{ind_Integer,basis}]:=ColorString[StringJoin[CIndexForm[ind,basis],"'"],BasisColor[basis]];
IndexForm[{ind_,basis}]:=ColorString[StringJoin[IndexForm[ind],"'"],BasisColor[basis]];
Protect[IndexForm];)
(*------------------------------------------------------------*)
(*
DefPrimedBasis[basis_,x__]:=(DefBasis[basis,x];PrimedIndexForm[basis]);
DefPrimedChart[chart_,x__]:=(DefChart[chart,x];PrimedIndexForm[chart]);
*)
(*------------------------------------------------------------*)
DoublePrimedIndexForm[basis_]:=(
Unprotect[IndexForm];
IndexForm[{ind_Integer,basis}]:=ColorString[StringJoin[CIndexForm[ind,basis],"''"],BasisColor[basis]];
IndexForm[{ind_,basis}]:=ColorString[StringJoin[IndexForm[ind],"''"],BasisColor[basis]];
Protect[IndexForm];
)
(*------------------------------------------------------------*)
(*
DefDoublePrimedBasis[basis_,x__]:=(DefBasis[basis,x];DoublePrimedIndexForm[basis]);
DefDoublePrimedChart[chart_,x__]:=(DefChart[chart,x];DoublePrimedIndexForm[chart]);
*)
(*------------------------------------------------------------*)


(* Diff *)
MakeExpression[TagBox[expr_,"DiffTag"],form_]:=
HoldComplete[expr]/.RowBox[{"d",x_}]:>Diff[ToExpression@x]
(*------------------------------------------------------------*)
(* LieD *)
MakeExpression[TagBox[expr_,"LieTag"],form_]:=(*HoldComplete[expr]/.RowBox[{SubscriptBox["\[ScriptCapitalL]",x_],y_}]\[RuleDelayed]LieD[ToExpression@x][ToExpression@y]*)
HoldComplete[expr]/.RowBox[{SubscriptBox[lie_,x_],y_}]:>LieD[ToExpression@x][ToExpression@y]
(*------------------------------------------------------------*)
(* Bracket *)
MakeExpression[TagBox[expr_,brtag_?(MemberQ[BracketTagsListUp,#]&)],form_]:=HoldComplete[expr]/.SuperscriptBox[
    RowBox[{"[",RowBox[{v1_,",",v2_}],"]"}], z_]:>Bracket[ToExpression@v1,ToExpression@v2][idxup[ToExpression@z,Symbol@StringSplit[brtag,"_"][[2]]]]
MakeExpression[TagBox[expr_,brtag_?(MemberQ[BracketTagsListDown,#]&)],form_]:=HoldComplete[expr]/.SubscriptBox[
    RowBox[{"[",RowBox[{v1_,",",v2_}],"]"}], z_]:>Bracket[ToExpression@v1,ToExpression@v2][idxdown[ToExpression@z,Symbol@StringSplit[brtag,"_"][[2]]]]
(*------------------------------------------------------------*)
(* OLD Bracket *)
(*
MakeExpression[TagBox[expr_,brtag_?(MemberQ[BracketTagsListUp,#]&)],form_]:=HoldComplete[expr]/.SuperscriptBox[
    RowBox[{"[",RowBox[{v1_,",",v2_}],"]"}], z_]\[RuleDelayed]Bracket[idxup[ToExpression@z,Symbol@StringSplit[brtag,"_"][[2]]]][ToExpression@v1,ToExpression@v2]
MakeExpression[TagBox[expr_,brtag_?(MemberQ[BracketTagsListDown,#]&)],form_]:=HoldComplete[expr]/.SubscriptBox[
    RowBox[{"[",RowBox[{v1_,",",v2_}],"]"}], z_]\[RuleDelayed]Bracket[idxdown[ToExpression@z,Symbol@StringSplit[brtag,"_"][[2]]]][ToExpression@v1,ToExpression@v2]
*)

(*------------------------------------------------------------*)
(* CovDs Up and Prefix *)
(* In the following code, I do not need to check too much der_, since I know it is acceptable from the tag*)
(* if the tag has been recognized, than der_ must be acceptable*)
MakeExpression[TagBox[expr_,cdtag_?(MemberQ[StringTagsListPrefixUp,#]&)],form_]:=HoldComplete[expr]/.
RowBox[{SuperscriptBox[der_, x_],y_}]:>(Symbol@First@StringSplit[cdtag,"_"])[idxup[ToExpression@x,Symbol@StringSplit[cdtag,"_"][[2]]]][ToExpression@y]
(* CovDs Down and Prefix *)
(* In the following code, I do not need to check too much der_, since I know it is acceptable from the tag*)
(* if the tag has been recognized, than der_ must be acceptable*)
MakeExpression[TagBox[expr_,cdtag_?(MemberQ[StringTagsListPrefixDown,#]&)],form_]:=HoldComplete[expr]/.RowBox[{SubscriptBox[der_, x_],y_}]:>(Symbol@First@StringSplit[cdtag,"_"])[idxdown[ToExpression@x,Symbol@StringSplit[cdtag,"_"][[2]]]][ToExpression@y]


HelpMenuContents:={"xPrint Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"xPrint","Documentation","English","xPrintDoc.nb"}]],"xPrint tutorials":>NotebookOpen[SystemDialogInput["FileOpen",FileNameJoin[{First@FileNames["xAct",$Path],"xPrint","Documentation","English","Tutorials"}]]],
Delimiter,
"xCore Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xCoreDoc.nb"}]], 
"xPerm Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xPermDoc.nb"}]],
Delimiter,
"xTensor Doc":> NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xTensorDoc.nb"}]], 
"xTensor Ref. Guide":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xTensorRefGuide.nb"}]],
Delimiter,
"xCoba Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xCobaDoc.nb"}]],
"xCoba Doc2":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xCobaDoc2.nb"}]],
Delimiter,
"xTerior Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xTeriorDoc.nb"}]],
Delimiter,
"xTras Doc":>SystemOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xTras.pdf"}]],
"SymManipulator Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","SymManipulatorDoc.nb"}]],
"xPert Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","xPertDoc.nb"}]],
 "Harmonics Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","HarmonicsDoc.nb"}]],
"Invar Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","InvarDoc.nb"}]],
 "Spinors Doc":>NotebookOpen[FileNameJoin[{First@FileNames["xAct",$Path],"Documentation","English","SpinorsDoc.nb"}]],
Delimiter,
 "xPrint site":>SystemOpen["http://sites.google.com/site/xprintforxact/"],
 "xAct site":>SystemOpen["http://xAct.es.html"](*SystemOpen["http://metric.iem.csic.es/Martin-Garcia/xAct/index.html"]*) ,
 "xAct group":>SystemOpen["http://groups.google.com/group/xact/topics?hl=en"],
Delimiter,
"About xPrint...":>DisplaySplash[5]}


HelpMenu:=Tooltip[ActionMenu[
                  Graphics[{
                    {RGBColor[0.689647, 0.761166, 0.805478], 
                    Disk[{0, 0}, 0.1]}, 
                    {GrayLevel[0], Circle[{0, 0}, 0.1], 
                    Style[Inset["\<\"?\"\>", {0.01, 0}], "Label",
                    FontSize->11]}},
                   ImageSize->{20, 20},BaselinePosition->Bottom], HelpMenuContents,
                  Appearance->None,
                  BaseStyle->"puL",
                  FrameMargins->{{0, 0}, {-2, -2}},
                  ImageSize->{20, 20}],"Help for working with xAct"]


pastebutton[Diff]:=Button[ToExpression@RowBox[{
  "d", "[", TagBox[
      FrameBox["form"],
      "Placeholder"], "]"}],
NotebookWrite[nb,TagBox[
      RowBox[{
  "d", 
  RowBox[{"(",TagBox[
      FrameBox["form"],
      "Placeholder"],")"}]}],
      "DiffTag"],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
(*------------------------------------------------------------*)
pastebutton[OverDot]:=Button[ToExpression@OverscriptBox[
 RowBox[{"(",TagBox[
      FrameBox["tensor"],
      "Placeholder"],")"}] , "."],
NotebookWrite[nb,OverscriptBox[
 RowBox[{"(",TagBox[
      FrameBox["tensor"],
      "Placeholder"],")"}] , "."],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
(*------------------------------------------------------------*)
pastebutton[ParamD/;paramchoice=!=""]:=Button[ToExpression@RowBox[{
  RowBox[{"ParamD", "[",ToString@ paramchoice, "]"}], "[", TagBox[
      FrameBox["tensor"],
      "Placeholder"], "]"}],
NotebookWrite[nb,RowBox[{
  RowBox[{"ParamD", "[",ToString@ paramchoice, "]"}], "[", TagBox[
      FrameBox["tensor"],
      "Placeholder"], "]"}],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
(*------------------------------------------------------------*)
pastebutton[LieD]:=Button[ToExpression@TagBox[
      RowBox[{
  SubscriptBox["\[ScriptCapitalL]", 
   TagBox[
      FrameBox["v"],
      "Placeholder"]], 
  RowBox[{"(",TagBox[
      FrameBox["tensor"],
      "Placeholder"],")"}]}],
      "LieTag"],
NotebookWrite[nb,TagBox[
      RowBox[{
  SubscriptBox[StyleBox[LieDSymbol,FontColor->Black], 
   TagBox[ FrameBox["v"],
      "Placeholder"]], 
  RowBox[{"(",TagBox[
      FrameBox["tensor"],
      "Placeholder"],")"}]}],
      "LieTag"],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
(*------------------------------------------------------------*)
pastebutton[Bracket/;(cup[1]=!="")]:=Button[Bracket[ToExpression@TagBox[
      FrameBox["vect1"],
      "Placeholder"],ToExpression@TagBox[
      FrameBox["vect2"],
      "Placeholder"]][cidx[1]]//DisplayForm,
NotebookWrite[nb,TagBox[
      SuperscriptBox[
    RowBox[{"[", 
     TagBox[
      FrameBox["vect1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["vect2"],
      "Placeholder"], "]"}], StyleBox[ToString[cup[1]],BasisColor[cbasischoice[1]]]],
      BracketTagUp[cbasischoice[1]]],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
pastebutton[Bracket/;(cdown[1]=!="")]:=Button[Bracket[ToExpression@TagBox[
      FrameBox["vect1"],
      "Placeholder"],ToExpression@TagBox[
      FrameBox["vect2"],
      "Placeholder"]][cidx[1]]//DisplayForm,
NotebookWrite[nb,TagBox[
      SubscriptBox[
    RowBox[{"[", 
     TagBox[
      FrameBox["vect1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["vect2"],
      "Placeholder"], "]"}], StyleBox[ToString[cdown[1]],BasisColor[cbasischoice[1]]]],
      BracketTagDown[cbasischoice[1]]],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
(*------------------------------------------------------------*)
(* OLD Bracket *)
(*pastebutton[Bracket/;(cup[1]=!="")]:=Button[Bracket[cidx[1]][ToExpression@TagBox[
      FrameBox["vect1"],
      "Placeholder"],ToExpression@TagBox[
      FrameBox["vect2"],
      "Placeholder"]]//DisplayForm,
NotebookWrite[nb,TagBox[
      SuperscriptBox[
    RowBox[{"[", 
     TagBox[
      FrameBox["vect1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["vect2"],
      "Placeholder"], "]"}], StyleBox[ToString[cup[1]],BasisColor[cbasischoice[1]]]],
      BracketTagUp[cbasischoice[1]]],Placeholder]
,ImageSize\[Rule]{im,45},Background\[Rule] LightGray,Appearance\[Rule]Button]&
pastebutton[Bracket/;(cdown[1]=!="")]:=Button[Bracket[cidx[1]][ToExpression@TagBox[
      FrameBox["vect1"],
      "Placeholder"],ToExpression@TagBox[
      FrameBox["vect2"],
      "Placeholder"]]//DisplayForm,
NotebookWrite[nb,TagBox[
      SubscriptBox[
    RowBox[{"[", 
     TagBox[
      FrameBox["vect1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["vect2"],
      "Placeholder"], "]"}], StyleBox[ToString[cdown[1]],BasisColor[cbasischoice[1]]]],
      BracketTagDown[cbasischoice[1]]],Placeholder]
,ImageSize\[Rule]{im,45},Background\[Rule] LightGray,Appearance\[Rule]Button]&
*)
(*------------------------------------------------------------*)
pastebutton[cdchoice_?CovDQ/;(cdown[1]=!="")]:=Button[(cdchoice@cidx[1])[ToExpression@TagBox[
      FrameBox["tensor"],
      "Placeholder"]],
NotebookWrite[nb,TagBox[
      RowBox[{
    SubscriptBox[Last@SymbolOfCovD[cdchoice], StyleBox[ToString[cdown[1]],BasisColor[cbasischoice[1]]]], 
    RowBox[{"(",TagBox[
      FrameBox["tensor"],
      "Placeholder"],")"}]}],
      StringTagPrefixDown[cdchoice,cbasischoice[1]]],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
pastebutton[cdchoice_?CovDQ/;(cup[1]=!="")]:=Button[(cdchoice@cidx[1])[ToExpression@TagBox[
      FrameBox["tensor"],
      "Placeholder"]],
NotebookWrite[nb,TagBox[
      RowBox[{
    SuperscriptBox[Last@SymbolOfCovD[cdchoice], StyleBox[ToString[cup[1]],BasisColor[cbasischoice[1]]]], 
    RowBox[{"(",TagBox[
      FrameBox["tensor"],
      "Placeholder"],")"}]}],
      StringTagPrefixUp[cdchoice,cbasischoice[1]]],Placeholder]
,ImageSize->{im,45},Background-> LightGray,Appearance->Button]&
(*------------------------------------------------------------*)
(* In all other cases, PasteButton works well, since we are pasting a complete expresssion or an incomplete one, but already taken care of with pasteexpr *)
pastebutton[cdchoice_]:=Tooltip[PasteButton[nb,
#,#,ImageSize->{im,45},Background-> LightGray,Appearance->Button],"PasteButton"]&


DisplaySplash[t_]:=(splashnb=CreateWindow[DocumentNotebook[{
TextCell["xPrint for xAct", "Title", TextAlignment->Center,FontColor->White,FontSlant->Italic],
TextCell["Version "<>First@xAct`xPrint`$Version,"Subtitle",TextAlignment->Center,FontColor->White],TextCell["created\n by\nAlessandro Stecchina","Subtitle",TextAlignment->Center,FontColor->White],TextCell["Copyright (C) 2009-"<>DateString["Year"]<>" by Alessandro Stecchina\nunder the General Public License\n
These packages come with ABSOLUTELY NO WARRANTY;\n for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details.","Section",FontColor->White]}],ShowCellBracket->False,Deployed->True,ShowGroupOpener->False,WindowSize->{752,600},WindowMovable->False, WindowElements->{},WindowFrame->"ThinFrame",Background->Black,WindowTitle->"Splash and Copyright Notice"];
Pause[t];
NotebookClose[splashnb];)


ManifoldMenu:=Item[Dynamic[Tooltip[PopupMenu[Dynamic[manifold],Union@$Manifolds,Alignment->Right,BaseStyle->"puL",Appearance->ActionMenu,ImageSize->{Automatic,20},FrameMargins->Small],"Manifold Menu"],UpdateInterval->5 ],Alignment->Center]


SortCovDsButton:=Button["//SortCovDs"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//SortCovDs", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//", 
  RowBox[{
   RowBox[{"SortCovDs", "[", 
    RowBox[{ TagBox[
    FrameBox["#"],
    "Placeholder"]
  , ",",TagBox[
    FrameBox["covd"],
    "Placeholder"] 
     }], "]"}], "&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


BracketToCovDButton:=Button["//BracketToCovD"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//BracketToCovD", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//", 
  RowBox[{
   RowBox[{"BracketToCovD", "[", 
    RowBox[{ TagBox[
    FrameBox["#"],
    "Placeholder"]
  , ",",TagBox[
    FrameBox["covd"],
    "Placeholder"] 
     }], "]"}], "&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


ChangeCovDButton:=Button["//ChangeCovD"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//ChangeCovD", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//", 
  RowBox[{
   RowBox[{"ChangeCovD", "[", 
    RowBox[{"#", ",", TagBox[
    FrameBox["from covd1"],
    "Placeholder"]
  , ",",TagBox[
    FrameBox["to covd2"],
    "Placeholder"] 
     }], "]"}], "&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


TraceBasisDummyButton:=Button["//TrBasisDummy"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"//","TraceBasisDummy"}]], "Input"],After],
False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//","TraceBasisDummy", "[", 
   "#", ",", TagBox[
    FrameBox["indices"],
    "Placeholder"], "]","&"}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


ToBasisButton:=Button["//ToBasis"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"//","ToBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]"}]], "Input"],After],
False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//","ToBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]", "[", 
  RowBox[{
   "#", ",", TagBox[
    FrameBox["indices"],
    "Placeholder"], "]","&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


FreeToBasisButton:=Button["//FreeToBasis"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"//","FreeToBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]"}]], "Input"],After],
False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//","FreeToBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]", "[", 
  RowBox[{
   "#", ",", TagBox[
    FrameBox["indices"],
    "Placeholder"], "]","&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


DummyToBasisButton:=Button["//DummyToBasis"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"//","DummyToBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]"}]], "Input"],After],
False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//","DummyToBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]", "[", 
  RowBox[{
   "#", ",", TagBox[
    FrameBox["indices"],
    "Placeholder"], "]","&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


SeparateBasisButton:=Button["//SeparateBasis"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//SeparateBasis", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//","SeparateBasis", "[", 
  TagBox[
   FrameBox["basis"],
   "Placeholder"], "]", "[", 
  RowBox[{
   "#", ",", TagBox[
    FrameBox["indices"],
    "Placeholder"], "]","&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


SimplificationButton:=Button["//Simplification"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//Simplification", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//", 
  RowBox[{
   RowBox[{"Simplification", "[", 
    RowBox[{"#", ",", 
     RowBox[{"UseMetricOnVBundle", "\[Rule]", 
      TagBox[
       FrameBox[
        RowBox[{
         RowBox[{"All", "/", "none"}], "/", "VBundleList"}]],
       "Placeholder"]}], ",", 
     RowBox[{"ExpandChristoffel", "\[Rule]", TagBox[
    FrameBox["False/True"],
    "Placeholder"]}], ",", 
     RowBox[{"Method", "->", TagBox[
    FrameBox["ChangeCovD/Implode"],
    "Placeholder"]}]}], "]"}], "&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


ContractMetricButton:=Button["//ContractMetric"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//ContractMetric", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//", 
  RowBox[{
   RowBox[{"ContractMetric", "[", 
    RowBox[{"#", ",", TagBox[
    FrameBox["metric"],
    "Placeholder"], ",", 
     RowBox[{"AllowUpperDerivatives", "\[Rule]", TagBox[
    FrameBox["False/True"],
    "Placeholder"]}], ",", 
     RowBox[{"OverDerivatives", "\[Rule]", TagBox[
    FrameBox["False/True"],
    "Placeholder"]}]}], "]"}], "&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


ContractBasisButton:=Button["//ContractBasis"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//ContractBasis", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//","ContractBasis", "[", 
  RowBox[{
   "#", ",", 
   TagBox[
    FrameBox["indices"],
    "Placeholder"]}],",",RowBox[{"OverDerivatives", "\[Rule]", TagBox[
    FrameBox["False/True"],
    "Placeholder"]}], "]","&"}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


CanonicalButton:=Button["//ToCanonical"//ButtonLabelStyle,
Switch[SimpleManipulationQ,
True,NotebookWrite[nb,Cell["//ToCanonical", "Input"],After],False,
NotebookWrite[nb,
Cell[BoxData[
 RowBox[{"//", 
  RowBox[{
   RowBox[{"ToCanonical", "[", 
    RowBox[{"#", ",", 
     RowBox[{"UseMetricOnVBundle", "\[Rule]", 
      TagBox[
       FrameBox[
        RowBox[{
         RowBox[{"All", "/", "none"}], "/", "VBundleList"}]],
       "Placeholder"]}], ",", 
     RowBox[{"ExpandChristoffel", "\[Rule]", TagBox[
    FrameBox["False/True"],
    "Placeholder"]}], ",", 
     RowBox[{"Method", "->", TagBox[
    FrameBox["ChangeCovD/Implode"],
    "Placeholder"]}]}], "]"}], "&"}]}]], "Input"],After]]
,ImageSize->85,
Background->Switch[SimpleManipulationQ,True,Automatic,False,Yellow]]


TensorManipulationsection :=Grid[{{Row[{Item[Style["   Tensor Manipulation   ",13(*,Bold*)],Alignment->Left],Tooltip[Row[{Checkbox[Dynamic[SimpleManipulationQ]],Style[" Basic ",10(*,Bold*)]}],"Basic or advanced (with options) manipulation"],"   ",Tooltip[ButtonBar[{
" + ":>NotebookWrite[nb,Cell[" + ", "Input"],After]," - ":>NotebookWrite[nb,Cell[" - ", "Input"],After]," \[Wedge] ":>NotebookWrite[nb,Cell[" \[Wedge] ", "Input"],After]}],"Algebraic operations"]}]},
{TabView[{
"Normalize"-> Dynamic@Row[{CanonicalButton,SimplificationButton}], "Basis"->Grid[{
{Dynamic@Row[{TraceBasisDummyButton}]},{Dynamic@Row[{ContractBasisButton,SeparateBasisButton}]},{Dynamic@Row[{ToBasisButton,FreeToBasisButton,DummyToBasisButton}]}}], "Metric"->Dynamic@Row[{ContractMetricButton}],"CovD"->Dynamic@Row[{ChangeCovDButton,BracketToCovDButton,SortCovDsButton}]}]}
},Alignment->Left]


GeneralSettingssection:= OpenerView[{Style["General Settings",13(*,Bold*)],
TabView[{"Verbosity"->Column[{
Row@{Checkbox[Dynamic[$DefInfoQ,($DefInfoQ=#;If[$DefInfoQ,NotebookWrite[nb,Cell["$DefInfoQ=True","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$DefInfoQ=False","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  Definition Info",10]},Row@{Checkbox[Dynamic[$UndefInfoQ,($UndefInfoQ=#;If[$UndefInfoQ,NotebookWrite[nb,Cell["$UndefInfoQ=True","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$UndefInfoQ=False","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  Un-Definition Info",10]},
Row@{Checkbox[Dynamic[IndicesScreenedQ,(IndicesScreenedQ=#;If[IndicesScreenedQ,NotebookWrite[nb,Cell["$PrePrint=ScreenDollarIndices","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$PrePrint=.","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  Screen Dollar Indices",10]},
Row@{Checkbox[Dynamic[$CVVerbose,($CVVerbose=#;If[$CVVerbose,NotebookWrite[nb,Cell["$CVVerbose = True","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$CVVerbose = False","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  Component Value verbose  ",10]}}],"CovD"->Column[{
Row@{Checkbox[Dynamic[$CommuteCovDsOnScalars,($CommuteCovDsOnScalars=#;If[$CommuteCovDsOnScalars,NotebookWrite[nb,Cell["$CommuteCovDsOnScalars=True","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$CommuteCovDsOnScalars=False","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  Commute CovD on Scalars",10(*,Bold*)]},Row@{Checkbox[Dynamic[PostfixStyleQ,(PostfixStyleQ=#;If[PostfixStyleQ,NotebookWrite[nb,Cell["$CovDFormat =\"\<Postfix\>\"","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$CovDFormat =\"\<Prefix\>\"","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  CovD Postfix notation",10]},
Row@{Column[{Dynamic@ActionMenu["Start",(#:>(NotebookWrite[nb,Cell["SortCovDsStart["<>ToString[#]<>"]","Input"],All];SelectionEvaluateCreateCell[nb]))&/@commderivativesmenuselection[manifold],Appearance->None],Dynamic@ActionMenu["Stop",(#:>(NotebookWrite[nb,Cell["SortCovDsStop["<>ToString[#]<>"]","Input"],All];SelectionEvaluateCreateCell[nb]))&/@commderivativesmenuselection[manifold],Appearance->None]}],Style["Automatic CovD commutation",10]}}],"Bases"->Column[{
Row@{Checkbox[Dynamic[IndicesScreenedQ,(IndicesScreenedQ=#;If[IndicesScreenedQ,NotebookWrite[nb,Cell["$PrePrint=ScreenDollarIndices","Input"],All];
SelectionEvaluateCreateCell[nb],NotebookWrite[nb,Cell["$PrePrint=.","Input"],All];
SelectionEvaluateCreateCell[nb]])&]],Style["  Automatic Basis Contraction  ",10]}}]}]
}]


GlobalEnvironmentsection:=OpenerView[{Style["Global Environment",13],
Column[{Row@{PasteButton["$ConstantSymbols"//ButtonLabelStyle,Defer@$ConstantSymbols,Appearance->Button,ImageSize->95],PasteButton["$Parameters"//ButtonLabelStyle,Defer@$Parameters,Appearance->Button,ImageSize->95]},Row@{PasteButton["$Manifolds"//ButtonLabelStyle,Defer@$Manifolds,Appearance->Button,ImageSize->95],PasteButton["$ProductManifolds"//ButtonLabelStyle,Defer@$ProductManifolds,Appearance->Button,ImageSize->95]},Row@{PasteButton["$VBundles"//ButtonLabelStyle,Defer@$VBundles,Appearance->Button,ImageSize->95],PasteButton["$SumVBundles"//ButtonLabelStyle,Defer@$SumVBundles,Appearance->Button,ImageSize->95]},Row@{PasteButton["$CovDs"//ButtonLabelStyle,Defer@$CovDs,Appearance->Button,ImageSize->95],PasteButton["$Tensors"//ButtonLabelStyle,Defer@$Tensors,Appearance->Button,ImageSize->95]},
Row@{PasteButton["$Metrics"//ButtonLabelStyle,Defer@$Metrics,Appearance->Button,ImageSize->95],PasteButton["$ProductMetrics"//ButtonLabelStyle,Defer@$ProductMetrics,Appearance->Button,ImageSize->95]},Row@{PasteButton["$Bases"//ButtonLabelStyle,Defer@$Bases,Appearance->Button,ImageSize->95],PasteButton["$Charts"//ButtonLabelStyle,Defer@$Charts,Appearance->Button,ImageSize->95]}},Center]
}]


Definitionssection:=OpenerView[{Style["Definitions",13],
Grid[{{Button["Def Manifold"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefManifold", "[", 
  RowBox[{TagBox[
    FrameBox["manifold"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["dim"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["index1"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["index2"],
      "Placeholder"]
}], "}"}]}], "]"}]], "Input"],After]
],Button["Def Product Manifold"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefManifold", "[", 
  RowBox[{
   TagBox[
    FrameBox["manifold"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["manifold1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["manifold2"],
      "Placeholder"]}], "}"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["index1"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["index2"],
      "Placeholder"]}], "}"}]}], "]"}]], "Input"],After]
]},{Button["Def VBundle"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefVBundle", "[", 
  RowBox[{
   TagBox[
    FrameBox["vbundle"],
    "Placeholder"], ",", " ", TagBox[
      FrameBox["manifold"],
      "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["dim"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["index1"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["index2"],
      "Placeholder"]}], "}"}]}], "]"}]], "Input"],After]
]},{Button["Def Parameter"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefParameter", "[", 
  TagBox[
   FrameBox["parameter"],
   "Placeholder"], "]"}]], "Input"],After]
],Button["Def Constant Symbol"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefConstantSymbol", "[", 
  TagBox[
   FrameBox["symbol"],
   "Placeholder"], "]"}]], "Input"],After]
]},{Button["Def Diff. Form"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefDiffForm", "[", 
  RowBox[{
   RowBox[{TagBox[
    FrameBox["Form"],
    "Placeholder"], "[", 
    RowBox[{
     RowBox[{ 
      TagBox[
       FrameBox["\[PlusMinus] index1"],
       "Placeholder"]}], ",", " ", 
     TagBox[
      FrameBox["\[PlusMinus] index2"],
      "Placeholder"]
     }], "]"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{TagBox[
      FrameBox["manifold1"],
      "Placeholder"], ",", TagBox[
      FrameBox["manifold2"],
      "Placeholder"],",",TagBox[
      FrameBox["parameter"],
      "Placeholder"]}], "}"}],",",
TagBox[
    FrameBox["degree"],
    "Placeholder"],",",
TagBox[
    FrameBox["symmetry"],
    "Placeholder"]}], "]"}]], "Input"],After]
]},{Button["Def Tensor"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefTensor", "[", 
  RowBox[{
   RowBox[{TagBox[
    FrameBox["tensor"],
    "Placeholder"], "[", 
    RowBox[{
     RowBox[{ 
      TagBox[
       FrameBox["\[PlusMinus] index1"],
       "Placeholder"]}], ",", " ", 
     TagBox[
      FrameBox["\[PlusMinus] index2"],
      "Placeholder"]
     }], "]"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{TagBox[
      FrameBox["manifold1"],
      "Placeholder"], ",", TagBox[
      FrameBox["manifold2"],
      "Placeholder"],",",TagBox[
      FrameBox["parameter"],
      "Placeholder"]}], "}"}],",",
TagBox[
    FrameBox["symmetry"],
    "Placeholder"]}], "]"}]], "Input"],After]
],ActionMenu["    Symmetry    "//ButtonLabelStyle,{"Symmetric":>NotebookWrite[nb,Cell[BoxData[
 RowBox[{"Symmetric", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["p1"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["p2"],
      "Placeholder"]}], "}"}]}], "]"}]], "Input"],After],"Antisymmetric":>NotebookWrite[nb,Cell[BoxData[
 RowBox[{"Antisymmetric", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["p1"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["p2"],
      "Placeholder"]}], "}"}](*, ",", " ", 
   TagBox[
    FrameBox["notation"],
    "Placeholder"]*)}], "]"}]], "Input"],After],"RiemannSymmetric":>NotebookWrite[nb,Cell[BoxData[
 RowBox[{"RiemannSymmetric", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["p1"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["p2"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["p3"],
      "Placeholder"], ",", " ", 
     TagBox[
      FrameBox["p4"],
      "Placeholder"]}], "}"}], ",", " ", 
   TagBox[
    FrameBox["notation"],
    "Placeholder"]}], "]"}]], "Input"],After]},Appearance->"PopupMenu"]},{Button["Def Cov. Derivative"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefCovD", "[", 
  RowBox[{
   RowBox[{
    TagBox[
     FrameBox["covd"],
     "Placeholder"], "[", 
    RowBox[{"-", 
     TagBox[
      FrameBox["idx"],
      "Placeholder"]}], "]"}], ",", 
   TagBox[
    FrameBox[
     RowBox[{"inner", " ", "vbundle"}]],
    "Placeholder"], ",", 
   RowBox[{"SymbolOfCovD", "->", " ", 
    RowBox[{"{", 
     RowBox[{
      TagBox[
       FrameBox["post_string"],
       "Placeholder"], ",", " ", 
      TagBox[
       FrameBox["pre_string"],
       "Placeholder"]}], "}"}]}]}], "]"}]], "Input"],After]
]},{Button["Def Metric"//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefMetric", "[", 
  RowBox[{
   TagBox[
    FrameBox["signdet"],
    "Placeholder"], ",", " ", 
   RowBox[{
    TagBox[
     FrameBox["metric"],
     "Placeholder"], "[", 
    RowBox[{
     RowBox[{"-", 
      TagBox[
       FrameBox["idx1"],
       "Placeholder"]}], ",", 
     RowBox[{"-", 
      TagBox[
       FrameBox["idx2"],
       "Placeholder"]}]}], "]"}], ",", " ", 
   TagBox[
    FrameBox["covd"],
    "Placeholder"], ",", " ", 
   RowBox[{"SymbolOfCovD", "->", " ", 
    RowBox[{"{", 
     RowBox[{
      TagBox[
       FrameBox["post_string"],
       "Placeholder"], ",", " ", 
      TagBox[
       FrameBox["pre_string"],
       "Placeholder"]}], "}"}]}]}], "]"}]], "Input"],After]
]},{Dynamic@Button["DefBasis"//ButtonLabelStyle,
Switch[indexform,unprimed,NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefBasis", "[", 
  RowBox[{
   TagBox[
    FrameBox["basis"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["vbundle"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["cnumber1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["cnumber2"],
      "Placeholder"]}], "}"}]}],","," BasisColor \[Rule] " ,TagBox[
      FrameBox["color"],
      "Placeholder"], "]"}]], "Input"],After],primed,NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefBasis", "[", 
  RowBox[{
   TagBox[
    FrameBox["basis"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["vbundle"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["cnumber1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["cnumber2"],
      "Placeholder"]}], "}"}]}],","," BasisColor \[Rule] " ,TagBox[
      FrameBox["color"],
      "Placeholder"],","," Primed \[Rule] True", "]"}]], "Input"],After],doubleprimed,NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefBasis", "[", 
  RowBox[{
   TagBox[
    FrameBox["basis"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["vbundle"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["cnumber1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["cnumber2"],
      "Placeholder"]}], "}"}]}],","," BasisColor \[Rule] " ,TagBox[
      FrameBox["color"],
      "Placeholder"],","," DoublePrimed \[Rule] True", "]"}]], "Input"],After]],ImageSize->{120,Automatic}
]},{Tooltip[RadioButtonBar[Dynamic[indexform],{unprimed->"a",primed->"a'",doubleprimed->"a''"}],"unprimed, primed, doubleprimed"],ActionMenu["       Color       "//ButtonLabelStyle,{"Red":>Paste@Defer@Red,"Magenta":>Paste@Defer@Magenta,"Green":>Paste@Defer@Green,"D.Green":>Paste@Defer@N@Darker@Green,"Blue":>Paste@Defer@Blue,"Cyan":>Paste@Defer@Cyan,"Purple":>Paste@Defer@Purple,"Brown":>Paste@Defer@Brown,"Yellow":>Paste@Defer@Yellow},Appearance->"PopupMenu"]},{Dynamic@Button["DefChart"//ButtonLabelStyle,
Switch[indexform,unprimed,NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefChart", "[", 
  RowBox[{
   TagBox[
    FrameBox["chart"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["manifold"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["cnumber1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["cnumber2"],
      "Placeholder"]}], "}"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      TagBox[
       FrameBox["x1"],
       "Placeholder"], "[", "]"}], ",", 
     RowBox[{
      TagBox[
       FrameBox["x2"],
       "Placeholder"], "[", "]"}]}], "}"}], ",", " ", 
   RowBox[{"ChartColor", " ", "\[Rule]", " ", 
    TagBox[
     FrameBox["color"],
     "Placeholder"]}]}], "]"}]], "Input"],After],primed,NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefChart", "[", 
  RowBox[{
   TagBox[
    FrameBox["chart"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["manifold"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["cnumber1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["cnumber2"],
      "Placeholder"]}], "}"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      TagBox[
       FrameBox["x1"],
       "Placeholder"], "[", "]"}], ",", 
     RowBox[{
      TagBox[
       FrameBox["x2"],
       "Placeholder"], "[", "]"}]}], "}"}], ",", " ", 
   RowBox[{"ChartColor", " ", "\[Rule]", " ", 
    TagBox[
     FrameBox["color"],
     "Placeholder"],","," Primed \[Rule] True"}]}], "]"}]], "Input"],After],doubleprimed,NotebookWrite[nb,Cell[BoxData[
 RowBox[{"DefChart", "[", 
  RowBox[{
   TagBox[
    FrameBox["chart"],
    "Placeholder"], ",", " ", 
   TagBox[
    FrameBox["manifold"],
    "Placeholder"], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     TagBox[
      FrameBox["cnumber1"],
      "Placeholder"], ",", 
     TagBox[
      FrameBox["cnumber2"],
      "Placeholder"]}], "}"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      TagBox[
       FrameBox["x1"],
       "Placeholder"], "[", "]"}], ",", 
     RowBox[{
      TagBox[
       FrameBox["x2"],
       "Placeholder"], "[", "]"}]}], "}"}], ",", " ", 
   RowBox[{"ChartColor", " ", "\[Rule]", " ", 
    TagBox[
     FrameBox["color"],
     "Placeholder"],","," DoublePrimed \[Rule] True"}]}], "]"}]], "Input"],After]]
,ImageSize->{120,Automatic}]},
{Invisible["A"],Button["PrintAs ->..."//ButtonLabelStyle,
NotebookWrite[nb,Cell[BoxData[
 RowBox[{"PrintAs", "->", 
  TagBox[
    FrameBox["string/function"],
    "Placeholder"]}]], "Input"],After]
]}}]
}]


BasesandChartssection:=OpenerView[{Style["Bases and Charts",13],Column[{Dynamic[If[Select[$Bases,(VBundleOfBasis[#]===TangentBundleOfManifold[manifold])&]=={},Item[Grid[{{Style[Tooltip[Button["a...z",basisreset[AIndex]; ],"Reset Basis Menus"]],Style[Tooltip[PasteButton[ "AIndex",AIndex,ImageSize->im,Appearance->Button],"Available Basis"],Black]}},Frame->True,FrameStyle->Directive[Black,Thick]]],Grid[{{Style[Tooltip[Button["a...z",basisreset[AIndex]; ],"Reset Basis Menus"],Black],Style[Tooltip[PasteButton[ "AIndex",AIndex,ImageSize->im,Appearance->Button],"Available Basis"],Black]}}~Join~Table[{Style[Tooltip[With[{bas=i},Button["a...z",basisreset[bas]; ]],"Reset Basis Menus"],BasisColor@i],Style[Tooltip[PasteButton[ ToString[i],Defer[#]&[i],ImageSize->im,Appearance->Button],"Available Basis"],BasisColor@i](*Sequence@@(PasteButton[#,ToExpression[#]//InputForm,ImageSize\[Rule]27]&/@((ToString[#]<>"[]")&/@(Coordinate[#, i]&/@CNumbersOf[i]))),"\[DoubleLongRightArrow]",Sequence@@(PasteButton[#,#,ImageSize\[Rule]27]&/@BasisArray[i][a]),*)},{i,Select[$Bases,(VBundleOfBasis[#]===TangentBundleOfManifold[manifold])&]}],Alignment->Left,Spacings->{0,0.1}, Frame->True,FrameStyle->Directive[Black,Thick]]]]}]}]


Perturbationssection:=
OpenerView[{Style["Perturbations",13],
Column[{PasteButton["Load xPert",Defer@(<<xAct`xPert`),Background-> LightGray,Appearance->Button],Invisible@"I"},Center]
}]


ExteriorFormssection:=
OpenerView[{Style["Exterior Forms",13],
Column[{"Under development",Invisible@"I"},Center]
}]


(* xPrint Palette *)
xPrintPaletteTitle="xPrint Palette v. "<>xAct`xPrint`$Version[[1]] (* see beginning of package for version info *)
im=135; (* horizontal size of PasteButton *)
ww=300; (* spacer size *)
www=3.1im;
LockednbQ=False;
(* Initialize options *)
space15="               "; (* a string of 15 spaces *)
nb:=If[LockednbQ,Lockednb,InputNotebook[]]
nbtitle:="WindowTitle"/.NotebookInformation[nb]
nbtitlepadded:=StringJoin[nbtitle,space15]
DisplayTargetNb:=StringTake[nbtitlepadded,15]
basisreset[AIndex]; (* initialize the first 10 basis indices to AIndex *)
cup[1]="";
cdown[1]="";
cbasischoice[1]=AIndex;
manifold="";
cdchoice="";
paramchoice="";
commcdchoice=="";
tensorhead="";
gdslots=1;


(* Palette contents *)
xPrintpaste:=Grid[{{Item[Row[{Style["   Target nb \[Rule]   ",13(*,Bold*)],Dynamic@(Tooltip[Panel[(Row[{DisplayTargetNb//ButtonLabelStyle}]),FrameMargins->Tiny,ImageSize->100],nbtitle]),Invisible["A"],Tooltip[Row[{Checkbox[Dynamic[LockednbQ,(LockednbQ=#;If[LockednbQ,Lockednb=InputNotebook[]])&]],Style[" Lock",10(*,Bold*)]}],"Lock current InputNotebook"]}],Alignment->Left],
(* Help Menu *)
Item[Row[{HelpMenu,Invisible["I"]}],Alignment->Right]},
(* Manifold Menu *)
{ManifoldMenu,SpanFromLeft},
(*-----------------------------------------------------------------------------------*)
{Row[{Dynamic@(pastebutton[cdchoice][pastedexpr]),"  ",Dynamic@
Row[
{
Tooltip[PopupMenu[Dynamic[cdchoice,(cdchoice=#;Which[
cdchoice=!="",
tensorhead=""
])&],derivativesmenuselection[manifold],Alignment->Right,Appearance->"Button",ImageSize->{Automatic,20},FrameMargins->Small],"Derivative Menu"],
Sequence@@
Table[
With[{kk=k},
Column[{
Tooltip[PopupMenu[Dynamic[cup[kk],(cup[kk]=#;Which[
cup[kk]=!="",
cdown[kk]="",
cup[kk]==="" && cdown[kk]==="",
cdown[kk]=(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]]//First
])&],Append[(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]] ~Join~cnumbersof[cbasischoice[kk]],""],Appearance->"Button",ImageSize->{20,20}],"up-index Menu"],
Tooltip[PopupMenu[Dynamic[cdown[kk],(cdown[kk]=#;Which[
cdown[kk]=!="",
cup[kk]="",
cup[kk]==="" && cdown[kk]==="",
cup[kk]=(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]]//First
])&],Append[(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]] ~Join~cnumbersof[cbasischoice[kk]],""],Appearance->"Button",ImageSize->{20,20}],"down-index Menu"],
Tooltip[PopupMenu[Dynamic[cbasischoice[kk]],Thread[abstractandbases[manifold]->abstractandbasesdisks[manifold]],Appearance->"Button",ImageSize->{20,20}],"Basis Menu"]},BaselinePosition->Scaled[0.66]]
],
{k,If[CovDQ[cdchoice]||cdchoice===Bracket,1,0]}
],
Sequence@@
Table[
With[{kk=k},
Column[{
Tooltip[PopupMenu[Dynamic[paramchoice],Append[$Parameters,""],Appearance->"Button",ImageSize->{Automatic,20}],"Parameter Menu"]},BaselinePosition->Scaled[0.66]]
],
{k,If[cdchoice===ParamD,1,0]}
],
Tooltip[PopupMenu[Dynamic[tensorhead,(tensorhead=#;Which[
tensorhead=!="",
cdchoice=""
])&],tensormenuselection[manifold],Alignment->Right,Appearance->"Button",ImageSize->{Automatic,20},FrameMargins->Small],"Tensor Menu"],
Sequence@@
Table[Tooltip[PopupMenu[Dynamic[gdslots],Range[If[Head@DimOfManifold[manifold]===Symbol,7,DimOfManifold[manifold]]],Alignment->Right,Appearance->"Button",ImageSize->{20,20}],"Gdelta slot Menu"],
{k,If[tensorhead===Gdelta,1,0]}
],
Sequence@@
Table[
With[{kk=k},
Switch[
Which[tensorhead===Gdelta,GdeltaSlots[gdslots]TangentBundleOfManifold[manifold],
tensorhead===delta,{-TangentBundleOfManifold[manifold],TangentBundleOfManifold[manifold]},
tensorhead===Basis,{-TangentBundleOfManifold[manifold],TangentBundleOfManifold[manifold]},
True,SlotsOfTensor[tensorhead]][[kk]],
Labels,Column[{
Dynamic[If[linput[kk]===Null,Invisible@"AA",linput[kk]]],
Invisible["AA"],
Tooltip[Button["LI",CreateDialog[{TextCell["Label: "],InputField[Dynamic[linput[kk]](*,String*),ContinuousAction->True],ChoiceButtons[{DialogReturn[label[kk]=linput[kk]],DialogReturn[]}]}];,ImageSize->{Automatic,20}],"Label Index"]},BaselinePosition->Scaled[0.74]],
-Labels,Column[{
Invisible["AA"],
Dynamic[If[linput[kk]===Null,Invisible@"AA",linput[kk]]],
Tooltip[Button["LI",CreateDialog[{TextCell["Label: "],InputField[Dynamic[linput[kk]](*,String*),ContinuousAction->True],ChoiceButtons[{DialogReturn[label[kk]=linput[kk]],DialogReturn[]}]}];,ImageSize->{Automatic,20}],"Label Index"]},BaselinePosition->Scaled[0.74]],
_,Column[{
If[Which[
tensorhead===Gdelta,GdeltaSlots[gdslots]TangentBundleOfManifold[manifold],
tensorhead===delta,{-TangentBundleOfManifold[manifold],TangentBundleOfManifold[manifold]},
tensorhead===Basis,{-TangentBundleOfManifold[manifold],TangentBundleOfManifold[manifold]},
True,SlotsOfTensor[tensorhead]][[kk]]===TangentBundleOfManifold[manifold]||MetricEndowedQ[TangentBundleOfManifold[manifold]],Tooltip[PopupMenu[Dynamic[up[kk],(up[kk]=#;Which[
up[kk]=!="",
down[kk]="",
up[kk]==="" && down[kk]==="",
down[kk]=(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]]//First
])&],Append[(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]] ~Join~cnumbersof[basischoice[kk]],""],Appearance->"Button",ImageSize->{20,20}],"up-index Menu"],Invisible["XXX"]],
If[Which[tensorhead===Gdelta,GdeltaSlots[gdslots]TangentBundleOfManifold[manifold],
tensorhead===delta,{-TangentBundleOfManifold[manifold],TangentBundleOfManifold[manifold]},
tensorhead===Basis,{-TangentBundleOfManifold[manifold],TangentBundleOfManifold[manifold]},
True,SlotsOfTensor[tensorhead]][[kk]]===-TangentBundleOfManifold[manifold]||MetricEndowedQ[TangentBundleOfManifold[manifold]],Tooltip[PopupMenu[Dynamic[down[kk],(down[kk]=#;Which[
down[kk]=!="",
up[kk]="",
up[kk]==="" && down[kk]==="",
up[kk]=(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]]//First
])&],Append[(IndicesOfVBundle@TangentBundleOfManifold[manifold])[[1]] ~Join~cnumbersof[basischoice[kk]],""],Appearance->"Button",ImageSize->{20,20}],"down-index Menu"],Invisible["XXX"]],
Tooltip[PopupMenu[Dynamic[basischoice[kk]],Thread[abstractandbases[manifold]->abstractandbasesdisks[manifold]],Appearance->"Button",ImageSize->{20,20}],"Basis Menu"]},BaselinePosition->Scaled[0.66]]]

],
{k,If[xTensorQ[tensorhead],
Which[tensorhead===Gdelta,2gdslots,
True,Length@SlotsOfTensor[tensorhead]],0]}
],Invisible["AAA"]
}]}]},
(*--------------------------------------------------------------------------*)
{TensorManipulationsection},
(*--------------------------------------------------------------------------*)
{GeneralSettingssection},
(*--------------------------------------------------------------------------*)
{GlobalEnvironmentsection},
(*--------------------------------------------------------------------------*)
{Definitionssection},
(*--------------------------------------------------------------------------*)
{BasesandChartssection},
(*--------------------------------------------------------------------------*)
{Perturbationssection},
(*--------------------------------------------------------------------------*)
{ExteriorFormssection}
},Alignment->Left,Dividers->{False,{False,False,False,{True},False}}]


(* This is the palette object and the initial palette creation *)
DisplaySplash[3];
xPrintPalette=
CreatePalette[xPrintpaste,
WindowTitle->xPrintPaletteTitle,Saveable->False];


$Epilog:=NotebookClose[xPrintPalette]


End[]


EndPackage[]
